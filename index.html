<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>game life</title>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #131313;
        }

        .row {
            display: flex;
            flex-direction: row;
        }

        .cell {
            width: 16px;
            height: 16px;
            background-color: black;
            border: 1px solid rgb(45, 45, 45);
        }

        .cell:hover {
            border: 1px solid red;
        }

        .alive {
            background-color: white;
        }

        #root {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <p style="color:white; padding-top: 20px; padding-bottom: 20px;">Move Cam - (← ↑ → ↓)</p>
    <script>

        /*

    Любая живая клетка, имеющая менее двух живых соседей, умирает, как будто из-за недостаточной численности населения.
    Любая живая клетка с двумя или тремя живыми соседями доживает до следующего поколения.
    Любая живая клетка, имеющая более трёх живых соседей, погибает, как бы от перенаселения.
    Любая мертвая клетка, имеющая ровно три живых соседа, становится живой клеткой, как бы путем размножения.

        */

        const pos2str = (x = 0, y = 0) => `${x}:${y}`;
        const str2pos = (pos = "0:0") => pos.split(":").map(v => +v);

        class Cell {
            constructor(x, y) {
                this.key = pos2str(x, y);
                this.x = x;
                this.y = y;

                this.aroundKeyPoints = [];
                
                for (let _y = -1; _y < 2; _y++) {
                    for (let _x = -1; _x < 2; _x++) {
                        if (!_x && !_y) continue; // игнор центральной точки
                        this.aroundKeyPoints.push(pos2str(this.x + _x, this.y + _y));
                    }
                }
            }

            calcCountAround(mapmgr) {
                return this.aroundKeyPoints.reduce((prev, pos) => prev + !!mapmgr.getPoint(...str2pos(pos)), 0);
            }
        }

        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            toString() {
                return pos2str(this.x, this.y);
            }
        }

        class MapManager {
            constructor() {
                this.map = new Map();
            }
            clear() { this.map.clear(); }
            getPoint(x, y) { return this.map.get(pos2str(x, y)); }
            setPoint(x, y) { this.map.set(pos2str(x, y), new Cell(x, y)); return true; }
            unsetPoint(x, y) { this.map.delete(pos2str(x, y)); }
        }

        class World {
            constructor() {
                this.mapmgr = new MapManager();

                this.viewport = {
                    pos: new Vector2(),
                    size: new Vector2(32, 32),
                };

            }

            countAroundPoint(x, y) {
                let count = 0;
                for (let _y = -1; _y < 2; _y++) {
                    for (let _x = -1; _x < 2; _x++) {
                        if (!_x && !_y) continue; // игнор центральной точки
                        count += !!this.mapmgr.getPoint(x + _x, y + _y);
                    }
                }
                return count;
            }

            checkIsAlive(isAlive, countAliveAround) {
                if (isAlive && countAliveAround < 2) return false;
                else if (isAlive && countAliveAround > 3) return false;
                else if (!isAlive && countAliveAround === 3) return true;
                else return isAlive;
            }

            // TODO: Тут есть ещё много чего, что можно оптимизировать
            nextTick() {
                const nextMap = new MapManager();
                this.mapmgr.map.forEach((cell, k) => {
                    // Проверяем мёртвые клетки вокруг
                    cell.aroundKeyPoints.forEach(pos => {
                        const aroundCell = this.mapmgr.getPoint(pos);
                        const numPos = str2pos(pos);
                        if (!aroundCell && this.checkIsAlive(false, this.countAroundPoint(...numPos)))
                            nextMap.setPoint(...numPos);

                    });

                    if (this.checkIsAlive(true, cell.calcCountAround(this.mapmgr))) {
                        nextMap.setPoint(cell.x, cell.y);
                    }

                });
                this.mapmgr = nextMap;
            }
        }

        var WORLD = new World();

        const root = document.getElementById('root');

        const clear = el => el && [...el.childNodes].forEach(cEl => cEl.remove());

        const updateVisualMap = () => {
            const rows = root.childNodes;
            for (let y = 0; y < WORLD.viewport.size.y; y++) {
                const row = rows[y];
                for (let x = 0; x < WORLD.viewport.size.x; x++) {
                    const cell = row.childNodes[x];
                    const virtCell = WORLD.mapmgr.getPoint(WORLD.viewport.pos.x + x, WORLD.viewport.pos.y + y);
                    if (!cell) continue;
                    
                    if (!virtCell) cell.classList.remove('alive');
                    else cell.classList.add('alive');
                }
            }
        }

        const genVisualMap = () => {
            for (let y = 0; y < WORLD.viewport.size.y; y++) {
                const row = document.createElement('div');
                row.className = 'row';
                for (let x = 0; x < WORLD.viewport.size.x; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = (e) => {
                        const vx = WORLD.viewport.pos.x + x;
                        const vy = WORLD.viewport.pos.y + y;

                        const alive = WORLD.mapmgr.getPoint(vx, vy);
                        if (!alive) {
                            WORLD.mapmgr.setPoint(vx, vy);
                            cell.classList.add('alive');
                        } else {
                            WORLD.mapmgr.unsetPoint(vx, vy);
                            cell.classList.remove('alive');
                        }
                    }
                    row.append(cell);
                }
                root.append(row);
            }
        }

        clear(root);
        genVisualMap();

        function nextTick() {
            WORLD.nextTick();
            updateVisualMap();
        }

        document.addEventListener('keydown', e => {
            switch(e.key) {
                case "ArrowLeft": {
                    WORLD.viewport.pos.x--;
                    break;
                }
                case "ArrowRight": {
                    WORLD.viewport.pos.x++;
                    break;
                }
                case "ArrowUp": {
                    WORLD.viewport.pos.y--;
                    break;
                }
                case "ArrowDown": {
                    WORLD.viewport.pos.y++;
                    break;
                }
            }
            updateVisualMap();
        });

        var auto = false;
        const setLiveMode = () => auto = !auto;
        setInterval(() => auto && nextTick(), 100);

        const clearMap = () => WORLD.mapmgr.clear();

    </script>
    <button onclick="nextTick()">next tick</button>
    <button onclick="setLiveMode()">live mode</button>
    <button onclick="clearMap()">clear map</button>
</body>

</html>